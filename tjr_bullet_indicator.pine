//@version=6
indicator("BPR [TakingProphets]", overlay=true, max_bars_back=500, max_boxes_count=500, max_lines_count=500, max_labels_count=500)

//----------------- UTILITIES & GUARDRAILS -----------------//
// CODE POLICY â€” do not direct-delete or set fields on objects/arrays; always use safeDel* or typed getters helpers.

// Safe object deletion (never delete na)
safeDelBox(x) =>
    if not na(x)
        box.delete(x)
safeDelLine(x) =>
    if not na(x)
        line.delete(x)
safeDelLabel(x) =>
    if not na(x)
        label.delete(x)

// Typed, bounds-safe getters
getBox(box[] a, int i) =>
    (i >= 0 and i < array.size(a)) ? array.get(a, i) : na
getLine(line[] a, int i) =>
    (i >= 0 and i < array.size(a)) ? array.get(a, i) : na
getLabel(label[] a, int i) =>
    (i >= 0 and i < array.size(a)) ? array.get(a, i) : na
getFloat(float[] a, int i) =>
    (i >= 0 and i < array.size(a)) ? array.get(a, i) : na
getInt(int[] a, int i) =>
    (i >= 0 and i < array.size(a)) ? array.get(a, i) : na
getBool(bool[] a, int i) =>
    (i >= 0 and i < array.size(a)) ? array.get(a, i) : bool(na)

// Session presence helper: only use this for session checks
inSess(tf, s, tz) =>
    not na(time(tf, s, tz))

//-------------------- INPUTS --------------------//
groupBPR = "BPR"
onOff = input.bool(true, "On/Off", group=groupBPR, inline="BPR_HDR")
bprColor = input.color(color.green, "Color", group=groupBPR, inline="BPR_HDR")
midlineOn = input.bool(true, "Midline", group=groupBPR, inline="BPR_HDR")
labelOpt = input.string("Tiny", "Label size", options=["Tiny","Small","Normal"], group=groupBPR, inline="BPR_HDR")

hideId1 = input.string("", "Hide ID 1", group=groupBPR, inline="BPR_HIDE")
hideId2 = input.string("", "Hide ID 2", group=groupBPR, inline="BPR_HIDE")
hideId3 = input.string("", "Hide ID 3", group=groupBPR, inline="BPR_HIDE")

searchStart = input.string("16:30", "Search start (HH:MM)", group=groupBPR, inline="BPR_T1")
searchEnd   = input.string("18:30", "Search end (HH:MM)", group=groupBPR, inline="BPR_T1")
displayStart= input.string("16:30", "Display start (HH:MM)", group=groupBPR, inline="BPR_T2")
displayEnd  = input.string("18:30", "Display end (HH:MM)", group=groupBPR, inline="BPR_T2")
deleteAt    = input.string("23:00", "Delete at (HH:MM)", group=groupBPR, inline="BPR_T3")

pvOn   = input.bool(false, "Preview", group=groupBPR, inline="BPR_PV")
pvTf   = input.string("30", "Source TF", options=["15","30","60","240","D"], group=groupBPR, inline="BPR_PV")
pvN    = input.int(4, "Show last N", minval=0, maxval=10, group=groupBPR, inline="BPR_PV")

//------------------ HELPERS ------------------//
labelSizeFromStr(s) =>
    s == "Small" ? size.small : s == "Normal" ? size.normal : size.tiny

// Helper for smart label placement inside or above the box (no chart.*)
placeLabel(top, bot, t0, isPreview) =>
    padY = math.max((top - bot) * 0.02, syminfo.mintick * 2)
    // Minimal box height (in price ticks) required to place text inside:
    minH = syminfo.mintick * (labelOpt == "Tiny" ? 6 : labelOpt == "Small" ? 10 : 14)
    y = (top - bot) >= minH ? (top - padY) : (top + padY)
    [t0 + 30 * 1000, y, labelSizeFromStr(labelOpt)]

//------------------- TIME FLAGS -------------------//
HHMM(strT) =>
    parts = str.split(strT, ":")
    h = int(str.tonumber((array.size(parts) > 0) ? array.get(parts, 0) : "0"))
    m = int(str.tonumber((array.size(parts) > 1) ? array.get(parts, 1) : "0"))
    str.tostring(h, "00") + str.tostring(m, "00")

HHMMplus1(strT) =>
    parts = str.split(strT, ":")
    h = int(str.tonumber((array.size(parts) > 0) ? array.get(parts, 0) : "0"))
    m = int(str.tonumber((array.size(parts) > 1) ? array.get(parts, 1) : "0"))
    m += 1
    if m == 60
        m := 0
        h += 1
    str.tostring(h, "00") + str.tostring(m, "00")

tfMinutes(tf) =>
    tf == "D" ? 1440 : int(str.tonumber(tf))

sec(tf, expr) =>
    request.security(syminfo.tickerid, tf, expr, gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_off)

sessSearch  = HHMM(searchStart)  + "-" + HHMM(searchEnd)
sessDisplay = HHMM(displayStart) + "-" + HHMM(displayEnd)
sessDelete  = HHMM(deleteAt)     + "-" + HHMMplus1(deleteAt)
TZ = "Asia/Jerusalem"

inSearch5   = inSess("5", sessSearch, TZ) // Only use inSess
inDisplayTF = inSess(timeframe.period, sessDisplay, TZ)
tDel        = time("1", sessDelete, TZ)
cleanup     = not na(tDel) and na(tDel[1])

//------------------- DATA MODEL -------------------//
var int nextBprId = 1
var int[] ids = array.new_int()
var box[] liveBoxes = array.new_box()
var line[] liveLines = array.new_line()
var label[] liveLabels = array.new_label()

var box[] pvBoxes = array.new_box()
var line[] pvLines = array.new_line()
var label[] pvLabels = array.new_label()
// Preview meta for mitigation logic
var float[] pvTops = array.new_float()
var float[] pvBots = array.new_float()
var int[]   pvTimes = array.new_int()

var float topB = na
var float botB = na
var int tB = na
var float topS = na
var float botS = na
var int tS = na

var float pvTopB = na
var float pvBotB = na
var int pvTB = na
var float pvTopS = na
var float pvBotS = na
var int pvTS = na

//------------------- UTILITIES -------------------//
reset_live() =>
    for i = 0 to array.size(liveBoxes) - 1
        safeDelBox(getBox(liveBoxes, i))
        safeDelLine(getLine(liveLines, i))
        safeDelLabel(getLabel(liveLabels, i))
    array.clear(liveBoxes)
    array.clear(liveLines)
    array.clear(liveLabels)
    array.clear(ids)

reset_preview() =>
    for i = 0 to array.size(pvBoxes) - 1
        safeDelBox(getBox(pvBoxes, i))
        safeDelLine(getLine(pvLines, i))
        safeDelLabel(getLabel(pvLabels, i))
    array.clear(pvBoxes)
    array.clear(pvLines)
    array.clear(pvLabels)
    array.clear(pvTops)
    array.clear(pvBots)
    array.clear(pvTimes)

bprFill = bprColor
pvFill = color.new(bprColor, 40)

//------------------- BUILDERS -------------------//
make_bpr(_tStart, _top, _bot, _id) =>
    b = box.new(_tStart, _top, _tStart + 5 * 60000, _bot, xloc=xloc.bar_time, extend=extend.right, border_color=color.black, bgcolor=bprFill)
    mid = (_top + _bot) / 2
    [lx, ly, lsz] = placeLabel(_top, _bot, _tStart, false)
    ln = line.new(_tStart, mid, _tStart + 5 * 60000, mid, xloc=xloc.bar_time, extend=extend.right, color=midlineOn ? color.black : color(na), style=line.style_dashed)
    lb = label.new(lx, ly, "BPR #" + str.tostring(_id), xloc=xloc.bar_time, yloc=yloc.price, style=label.style_label_left, size=lsz, textcolor=color.black, color=color(na))
    array.push(ids, _id)
    array.push(liveBoxes, b)
    array.push(liveLines, ln)
    array.push(liveLabels, lb)
    // Enforce FIFO max objects
    while array.size(liveBoxes) > 500
        safeDelBox(array.shift(liveBoxes))
        safeDelLine(array.shift(liveLines))
        safeDelLabel(array.shift(liveLabels))
        array.shift(ids)

make_preview_bpr(_tStart, _top, _bot) =>
    tfMs = tfMinutes(pvTf) * 60000
    b = box.new(_tStart, _top, _tStart + tfMs, _bot, xloc=xloc.bar_time, extend=extend.right, border_color=color.black, bgcolor=pvFill)
    mid = (_top + _bot) / 2
    [lx, ly, lsz] = placeLabel(_top, _bot, _tStart, true)
    ln = line.new(_tStart, mid, _tStart + tfMs, mid, xloc=xloc.bar_time, extend=extend.right, color=midlineOn ? color.black : color(na), style=line.style_dashed)
    lb = label.new(lx, ly, "BPR [PV]", xloc=xloc.bar_time, yloc=yloc.price, style=label.style_label_left, size=lsz, textcolor=color.black, color=color(na))
    array.push(pvBoxes, b)
    array.push(pvLines, ln)
    array.push(pvLabels, lb)
    array.push(pvTops, _top)
    array.push(pvBots, _bot)
    array.push(pvTimes, _tStart)
    // Enforce FIFO max objects (after mitigation logic)
    // (Handled after mitigation logic in main)

update_live_styles() =>
    for i = 0 to array.size(liveBoxes) - 1
        b = getBox(liveBoxes, i)
        ln = getLine(liveLines, i)
        lb = getLabel(liveLabels, i)
        if not na(b)
            box.set_bgcolor(b, inDisplayTF ? bprFill : color.new(color.white, 100))
        if not na(ln)
            line.set_color(ln, inDisplayTF and midlineOn ? color.black : color(na))
        if not na(lb)
            label.set_textcolor(lb, inDisplayTF ? color.black : color(na))
            label.set_color(lb, color(na))
            label.set_size(lb, labelSizeFromStr(labelOpt))

update_preview_styles() =>
    for i = 0 to array.size(pvBoxes) - 1
        b = getBox(pvBoxes, i)
        ln = getLine(pvLines, i)
        lb = getLabel(pvLabels, i)
        if not na(b)
            box.set_bgcolor(b, pvFill)
        if not na(ln)
            line.set_color(ln, midlineOn ? color.black : color(na))
        if not na(lb)
            label.set_color(lb, color(na))
            label.set_size(lb, labelSizeFromStr(labelOpt))

//------------------- MAIN -------------------//
if barstate.isnew
    if cleanup
        reset_live()
        reset_preview()
        nextBprId := 1
        topB := na
        botB := na
        tB := na
        topS := na
        botS := na
        tS := na
        pvTopB := na
        pvBotB := na
        pvTB := na
        pvTopS := na
        pvBotS := na
        pvTS := na
    else
        if not onOff
            reset_live()
            topB := na
            botB := na
            tB := na
            topS := na
            botS := na
            tS := na
        if not pvOn and (array.size(pvBoxes) > 0 or array.size(pvLines) > 0 or array.size(pvLabels) > 0)
            reset_preview()
            pvTopB := na
            pvBotB := na
            pvTB := na
            pvTopS := na
            pvBotS := na
            pvTS := na
    if onOff
        hid1 = str.tonumber(hideId1)
        hid2 = str.tonumber(hideId2)
        hid3 = str.tonumber(hideId3)
        for i = array.size(ids) - 1 to 0
            idv = getInt(ids, i)
            if not na(idv) and ((not na(hid1) and idv == hid1) or (not na(hid2) and idv == hid2) or (not na(hid3) and idv == hid3))
                safeDelBox(getBox(liveBoxes, i))
                safeDelLine(getLine(liveLines, i))
                safeDelLabel(getLabel(liveLabels, i))
                array.remove(liveBoxes, i)
                array.remove(liveLines, i)
                array.remove(liveLabels, i)
                array.remove(ids, i)
        //--- 5min logic (session-gated)
        t5 = request.security(syminfo.tickerid, "5", time, gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_off)
        h5 = request.security(syminfo.tickerid, "5", high, gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_off)
        l5 = request.security(syminfo.tickerid, "5", low,  gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_off)
        newBar5 = (t5 != t5[1])
        if inSearch5 and newBar5
            bullFvg = l5[1] > h5[2]
            bearFvg = h5[1] < l5[2]
            if bullFvg
                tB   := request.security(syminfo.tickerid, "5", time,    gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_off)
                topB := request.security(syminfo.tickerid, "5", low[1],  gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_off)
                botB := request.security(syminfo.tickerid, "5", high[2], gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_off)
                if not na(topS)
                    overTop = math.min(topB, topS)
                    overBot = math.max(botB, botS)
                    if overTop > overBot
                        id = nextBprId
                        nextBprId += 1
                        tStart = math.min(tB, tS)
                        make_bpr(tStart, overTop, overBot, id)
            if bearFvg
                tS   := request.security(syminfo.tickerid, "5", time,    gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_off)
                topS := request.security(syminfo.tickerid, "5", low[2],  gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_off)
                botS := request.security(syminfo.tickerid, "5", high[1], gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_off)
                if not na(topB)
                    overTop = math.min(topB, topS)
                    overBot = math.max(botB, botS)
                    if overTop > overBot
                        id = nextBprId
                        nextBprId += 1
                        tStart = math.min(tB, tS)
                        make_bpr(tStart, overTop, overBot, id)
        update_live_styles()
    //--- Preview logic (always scans, no session gates)
    if pvOn
        tPv = sec(pvTf, time)
        closePv = sec(pvTf, close)
        newPv = (tPv != tPv[1])
        if newPv
            if array.size(pvBoxes) > 0
                i = 0
                while i < array.size(pvBoxes)
                    top = getFloat(pvTops, i)
                    bot = getFloat(pvBots, i)
                    tC  = getInt(pvTimes, i)
                    if tPv > tC and ((closePv > top) or (closePv < bot))
                        safeDelBox(getBox(pvBoxes, i))
                        safeDelLine(getLine(pvLines, i))
                        safeDelLabel(getLabel(pvLabels, i))
                        array.remove(pvBoxes, i)
                        array.remove(pvLines, i)
                        array.remove(pvLabels, i)
                        array.remove(pvTops, i)
                        array.remove(pvBots, i)
                        array.remove(pvTimes, i)
                    else
                        i += 1
            bullPv = sec(pvTf, barstate.isconfirmed and low[1] > high[2])
            bearPv = sec(pvTf, barstate.isconfirmed and high[1] < low[2])
            if bullPv
                pvTB   := sec(pvTf, time[1])
                pvTopB := sec(pvTf, low[1])
                pvBotB := sec(pvTf, high[2])
                if not na(pvTopS)
                    overTop = math.min(pvTopB, pvTopS)
                    overBot = math.max(pvBotB, pvBotS)
                    if overTop > overBot
                        tStart = math.min(pvTB, pvTS)
                        make_preview_bpr(tStart, overTop, overBot)
            if bearPv
                pvTS   := sec(pvTf, time[1])
                pvTopS := sec(pvTf, low[2])
                pvBotS := sec(pvTf, high[1])
                if not na(pvTopB)
                    overTop = math.min(pvTopB, pvTopS)
                    overBot = math.max(pvBotB, pvBotS)
                    if overTop > overBot
                        tStart = math.min(pvTB, pvTS)
                        make_preview_bpr(tStart, overTop, overBot)
        while array.size(pvBoxes) > pvN
            safeDelBox(array.shift(pvBoxes))
            safeDelLine(array.shift(pvLines))
            safeDelLabel(array.shift(pvLabels))
            array.shift(pvTops)
            array.shift(pvBots)
            array.shift(pvTimes)
        update_preview_styles()
